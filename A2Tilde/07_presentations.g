
UniversalGroupRaduDatumWithCover := function(radu_datum_with_cover)
    local ls, edges, triangles, edge_labels, free_group, gens, rels;
    ls := LocalStructuresRaduDatumWithCover(radu_datum_with_cover);
    edges := ls[2];
    triangles := ls[4];
    edge_labels := List(edges, e->LabelSimplex(ls, e));
    free_group := FreeGroup(edge_labels);
    gens := GeneratorsOfGroup(free_group);
    rels := List(triangles, t-> gens[t[1]] * gens[t[2]]* gens[t[3] ]);
    return free_group/rels;
end;

MaximalTreeRaduDatumWithCover := function(radu_datum_with_cover)
    local ls, vertices, edges, vertices_of_edge, tree_vertices, tree_edges, e, vw;
    ls := LocalStructuresRaduDatumWithCover(radu_datum_with_cover);
    vertices := ls[1];
    edges := ls[2];
    vertices_of_edge := function(e)
        return Filtered(vertices, v-> e in v);
    end;
    tree_vertices := [];
    tree_edges := [];
    for e in edges do
        vw := vertices_of_edge(e);
        if Size(Intersection(tree_vertices, vw)) < 2 then
            Add(tree_edges, e);
            Append(tree_vertices, vw);
            tree_vertices := SSortedList(tree_vertices);
        fi;
        if Size(tree_vertices) = Size(vertices) then
            break;
        fi;
    od;
    return tree_edges;
end;

RandomMaximalTreeRaduDatumWithCover := function(radu_datum_with_cover)
    local ls, vertices, edges, vertices_of_edge, tree_vertices, tree_edges, e, vw;
    ls := LocalStructuresRaduDatumWithCover(radu_datum_with_cover);
    vertices := ls[1];
    edges := ls[2];
    vertices_of_edge := function(e)
        return Filtered(vertices, v-> e in v);
    end;
    tree_vertices := [];
    tree_edges := [];
    repeat
        e := Random(edges);
        vw := vertices_of_edge(e);
        if Size(Intersection(tree_vertices, vw)) < 2 then
            Add(tree_edges, e);
            Append(tree_vertices, vw);
            tree_vertices := SSortedList(tree_vertices);
        fi;
    until Size(tree_vertices) = Size(vertices);
    return tree_edges;
end;

FundamentalGroupRaduDatumWithCoverTree := function(radu_datum_with_cover, tree, info)
    local universal_group, gens, rels, e, i, ls, edges, pi;
    ls := LocalStructuresRaduDatumWithCover(radu_datum_with_cover);
    universal_group := UniversalGroupRaduDatumWithCover(radu_datum_with_cover);
    gens := GeneratorsOfGroup(universal_group);
    rels := List(tree, e->gens[e]);
    pi := universal_group/rels;
    if info then
        Print("We return the fundamental group of the corresponding delta complex.\n");
        Print("It is generated by the edges.\n");
        Print("We factored out the maximal tree with edges ");
        for i in [1.. Size(tree)-1] do
            e := tree[i];
            Print(LabelSimplex(ls,e), ", ");
        od;
        i := Size(tree);
        e := tree[i];
        Print(LabelSimplex(ls,e), ".\n");
        Print("With SimplifiedFpGroup you obtain an isomorphic group with ", Size(GeneratorsOfGroup(SimplifiedFpGroup(pi))), " generators.\n\n");
    fi;
    return pi;
end;

FundamentalGroupRaduDatumWithCover := function(radu_datum_with_cover)
    local tree;
    tree := MaximalTreeRaduDatumWithCover(radu_datum_with_cover);
    return FundamentalGroupRaduDatumWithCoverTree(radu_datum_with_cover, tree, false);
end;

ConvinientFundamentalGroupRaduDatumWithCover := function(radu_datum_with_cover)
    local universal_group, gens, rels_for_tree, e, i, delta_complex, edges,
    score_of_tree, best_tree, best_score, tree, pi;
    #
    score_of_tree := function(tree)
        return Size(GeneratorsOfGroup(SimplifiedFpGroup(FundamentalGroupRaduDatumWithCoverTree(radu_datum_with_cover, tree, false) )) );
    end;
    ###
    best_tree := MaximalTreeRaduDatumWithCover(radu_datum_with_cover);
    best_score := score_of_tree(best_tree);
    for i in [1..500] do
        tree := RandomMaximalTreeRaduDatumWithCover(radu_datum_with_cover);
        if score_of_tree(tree) < best_score then
            best_tree := tree;
            best_score := score_of_tree(tree);
        fi;
    od;
    pi := FundamentalGroupRaduDatumWithCoverTree(radu_datum_with_cover, best_tree, false);
    return pi;
end;

FiniteSimpleQuotients := function(g, max_size, info)
    local simpler_g, it, q, epis, description, size, i, quotient;
    quotient := false;
    simpler_g := SimplifiedFpGroup(g);
    if not IsPerfect(simpler_g) then
        Print("The group is not perfect, there are abelian quotients!\n \n");
    fi;
    if info then
        Print("We simplified the presentation, we now have ", Size(GeneratorsOfGroup(simpler_g)), " generators.\n\n");
    fi;
    it := SimpleGroupsIterator(1);
    i := 0;
    for q in it do
        i := i + 1;
        description := StructureDescription(q);
        size := Size(q);
        if size >= max_size then
            break;
        else
            epis := GQuotients(simpler_g, q : findall := false);
            if info then
                Print("Current time: ", CurrentDateTimeString(), ".\n");
            fi;
            if epis = [] then
                if info then
                    Print("There is no epimorphism to ", description,  " of Size ", size, " at position ", i, "\n\n");
                fi;
            else
                if info then
                    Print("There actually is an epimorphism to ", description,  " of Size ", size, " at position ", i, "\n\n");
                fi;
                quotient := true;
                break;
            fi;
        fi;
    od;
    if quotient = false then
        if info then
            Print("There no simple quotient of size <", max_size, ".\n\n");
        fi;
    fi;
    return epis;
end;